<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>English on nonacosa's Blog</title><link>https://blog.env.wtf/categories/english/</link><description>Recent content in English on nonacosa's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 06 May 2023 03:42:00 +0700</lastBuildDate><atom:link href="https://blog.env.wtf/categories/english/index.xml" rel="self" type="application/rss+xml"/><item><title>总览 RocketMq</title><link>https://blog.env.wtf/p/overview-of-rocketmq/</link><pubDate>Sat, 06 May 2023 03:42:00 +0700</pubDate><guid>https://blog.env.wtf/p/overview-of-rocketmq/</guid><description>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_2101681712181_.pic_hd.jpg" alt="Featured image of post 总览 RocketMq" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>公司进行了巨大的组织调整，被迫接手了一些中间件，为了能以后更好的展开工作和维护，整体过了一下 RocketMq 的文档，结合实际场景，记录一些要点。&lt;/p>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>Producer、Topic、Queue、Consumer Group、Consumer 之间的关系：&lt;/p>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_3a712b60-fb21-41b4-8a66-9c138c197375.png"
width="3388"
height="1244"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hufa994b1a8d80c78cd9f4190921a1b786_577157_5b3c1db58e3554f87c774add7f3cc512.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hufa994b1a8d80c78cd9f4190921a1b786_577157_da651a3e1cdcc0769a54e2f237e80025.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="272"
data-flex-basis="653px"
>&lt;/p>
&lt;h3 id="topic">Topic&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Normal: 普通消息（大部分场景）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FIFO：先进先出，严格按照投递顺序（数据同步场景）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Delay：延时消息（补偿/定时 查询）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Transaction：事物消息&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="queue">Queue&lt;/h3>
&lt;p>消息操作是面向 topic，实际数据是由 Queue 承接的，通过增加 Queue 数量以此实现水平扩容。&lt;/p>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_37f7aa8a-1805-42fd-848d-c7686c2d939d.png"
width="1088"
height="978"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hu9c5dfe444cdd4533e77d96a1d805407e_51131_fa4930f9ae2ce8fa3b0bb1759ee236be.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hu9c5dfe444cdd4533e77d96a1d805407e_51131_f75f8342a597a2f53a59fc56465a898f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="111"
data-flex-basis="266px"
>&lt;/p>
&lt;p>perm 权限：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>6 读写状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>4 只读状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2 只写状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>0 不可读写&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="message">Message&lt;/h3>
&lt;p>Message 消息不可变、默认持久化，存储在当前 Queue，携带：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>消息点位（ &lt;strong>RocketMq&lt;/strong> 生成的 &lt;strong>consumerOffset&lt;/strong> 记录消费位置）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消息 ID （全局唯一）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Key（快速索引，用于控制台）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Tag（ &lt;strong>Producer&lt;/strong> 决定）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>时间戳（Delay 场景， &lt;strong>Producer&lt;/strong> 决定，最大 30 day）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消息发送时间（客户端本地时间戳）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消息保存时间（服务端本地时间戳，&lt;span style="background-color: rgba(244, 238, 238, 1);">可以结合消息发送时间排查一些本体延迟问题&lt;/span>）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消费重试次数（每次 retry，次数 +1，兜底策略）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消息体约束（普通 &amp;amp; 顺序：4M，事物 &amp;amp; 定时 &amp;amp; 延时：64k）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_7c604b40-acd7-4ad8-9f01-dcadf910a61c.png"
width="837"
height="543"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hu08aa26b5173402316ad0e4b8f118d896_62952_52231808f2541106cf822d4ef1478a75.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hu08aa26b5173402316ad0e4b8f118d896_62952_0e2ddb795b98bbb7a98f31ee3ebb0a59.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="154"
data-flex-basis="369px"
>&lt;/p>
&lt;p>&lt;strong>消费重试策略概述&lt;/strong>&lt;/p>
&lt;p>消费重试指的是，消费者在消费某条消息失败后，Apache RocketMQ 服务端会根据重试策略重新消费该消息，超过一次定数后若还未消费成功，则该消息将不再继续重试，直接被发送到死信队列中。&lt;/p>
&lt;p>&lt;strong>重试次数&lt;/strong>&lt;/p>
&lt;p>假设最大重试次数为默认 3 次，则该消息最多可被投递4次，1次为原始消息，3次为重试投递次数。由消费者分组创建时的元数据控制。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>第几次重试&lt;/th>
&lt;th>与上次重试的间隔时间&lt;/th>
&lt;th>第几次重试&lt;/th>
&lt;th>与上次重试的间隔时间&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>10秒&lt;/td>
&lt;td>9&lt;/td>
&lt;td>7分钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>30秒&lt;/td>
&lt;td>10&lt;/td>
&lt;td>8分钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>1分钟&lt;/td>
&lt;td>11&lt;/td>
&lt;td>9分钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>2分钟&lt;/td>
&lt;td>12&lt;/td>
&lt;td>10分钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>3分钟&lt;/td>
&lt;td>13&lt;/td>
&lt;td>20分钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>4分钟&lt;/td>
&lt;td>14&lt;/td>
&lt;td>30分钟&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>5分钟&lt;/td>
&lt;td>15&lt;/td>
&lt;td>1小时&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>6分钟&lt;/td>
&lt;td>16&lt;/td>
&lt;td>2小时&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;!--more--> **重试触发条件：**
&lt;ul>
&lt;li>
&lt;p>消费失败，包括消费者返回消息失败状态标识或抛出非预期异常。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消息处理超时，包括在 PushConsumer 中排队超时。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="producer">Producer&lt;/h3>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_5731507d-842c-46b8-af87-9723a5028413.png"
width="902"
height="481"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hu105e35e877c07fede13bc3083ada79dd_38113_9ef7cf489591b3329179441055bc87db.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hu105e35e877c07fede13bc3083ada79dd_38113_2c8f594a54eb1ff93754698b0bc2e30e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="187"
data-flex-basis="450px"
>&lt;/p>
&lt;h3 id="consumergroup">&lt;strong>ConsumerGroup&lt;/strong>&lt;/h3>
&lt;p>消费者分组并不是运行实体，而是一个逻辑资源，通过消费者分组内初始化多个消费者实现消费性能的水平扩展以及高可用容灾。&lt;/p>
&lt;p>要求同一分组下的所有消费者以下消费行为保持一致：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>投递顺序&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>消费重试策略&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="consumer">Consumer&lt;/h3>
&lt;p>支持 PushConsumer 、 SimpleConsumer 以及 PullConsumer 这三种类型的消费者&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>对比项&lt;/th>
&lt;th>PushConsumer&lt;/th>
&lt;th>SimpleConsumer&lt;/th>
&lt;th>PullConsumer&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>接口方式&lt;/td>
&lt;td>使用监听器回调接口返回消费结果，消费者仅允许在监听器范围内处理消费逻辑。&lt;/td>
&lt;td>业务方自行实现消息处理，并主动调用接口返回消费结果。&lt;/td>
&lt;td>业务方自行按队列拉取消息，并可选择性地提交消费结果&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>消费并发度管理&lt;/td>
&lt;td>由SDK管理消费并发度。&lt;/td>
&lt;td>由业务方消费逻辑自行管理消费线程。&lt;/td>
&lt;td>由业务方消费逻辑自行管理消费线程。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>负载均衡粒度&lt;/td>
&lt;td>5.0 SDK是消息粒度，更均衡，早期版本是队列维度&lt;/td>
&lt;td>消息粒度，更均衡&lt;/td>
&lt;td>队列粒度，吞吐攒批性能更好，但容易不均衡&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>接口灵活度&lt;/td>
&lt;td>高度封装，不够灵活。&lt;/td>
&lt;td>原子接口，可灵活自定义。&lt;/td>
&lt;td>原子接口，可灵活自定义。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>适用场景&lt;/td>
&lt;td>适用于无自定义流程的业务消息开发场景。&lt;/td>
&lt;td>适用于需要高度自定义业务流程的业务开发场景。&lt;/td>
&lt;td>仅推荐在流处理框架场景下集成使用&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;!--more-->关于三种详细的差别细节：[消费者分类 | RocketMQ (apache.org)](https://rocketmq.apache.org/zh/docs/featureBehavior/06consumertype)
&lt;h3 id="subscription">Subscription&lt;/h3>
&lt;p>一个订阅关系指的是指定 &lt;strong>某个消费者&lt;/strong> 分组对于 &lt;strong>某个主题&lt;/strong> 的订阅&lt;/p>
&lt;p>不同消费组，订阅同一个 Topic ，互为两个订阅关系，相互独立：&lt;/p>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_fbe60c42-3f67-4f89-b2fb-0927e7b7d442.png"
width="1193"
height="737"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_huc11a91955ef1ad8e2097e3c08e30e777_128675_60bf9a62a6a0ce3e812b6a46ec006289.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_huc11a91955ef1ad8e2097e3c08e30e777_128675_af7f42d31ec3ddfb70b0125f06a324d9.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="388px"
>&lt;/p>
&lt;p>同一消费组订阅不同 Topic ，互为两个订阅关系，相互独立：&lt;/p>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_bf65a9be-023b-4efc-8f55-bacd5f06cd06.png"
width="1345"
height="466"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hue5961a886be6ec01a3ccf30a49637a98_102486_dbbf2d5869560f7fac36d1dea7307c08.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hue5961a886be6ec01a3ccf30a49637a98_102486_242ceaf511917130e6b3cc248322fe41.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="288"
data-flex-basis="692px"
>&lt;/p>
&lt;h2 id="最佳实践">最佳实践：&lt;/h2>
&lt;h3 id="tag">Tag&lt;/h3>
&lt;p>一个应用尽可能用一个Topic，而消息子类型则可以用tags来标识。tags可以由应用自由设置，只有生产者在发送消息设置了tags，消费方在订阅消息时才可以利用tags通过broker做消息过滤&lt;/p>
&lt;h3 id="keys">Keys&lt;/h3>
&lt;p>每个消息在业务层面一般建议映射到业务的唯一标识并设置到keys字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引（哈希索引），应用可以通过topic、key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证key尽可能唯一&lt;/p>
&lt;h3 id="业务日志httpsrocketmqapacheorgzhdocsbestpractice01bestpracticee697a5e5bf97e79a84e68993e58db0">业务日志&lt;a class="link" href="https://rocketmq.apache.org/zh/docs/bestPractice/01bestpractice#%E6%97%A5%E5%BF%97%E7%9A%84%E6%89%93%E5%8D%B0" target="_blank" rel="noopener"
>&lt;/a>&lt;/h3>
&lt;p>消息发送成功或者失败要打印消息日志，用于业务排查问题。Send消息方法只要不抛异常，就代表发送成功。&lt;/p>
&lt;h3 id="消息发送失败处理方式">&lt;strong>消息发送失败处理方式&lt;/strong>&lt;/h3>
&lt;p>如果业务要求消息发送不能丢，仍然需要对可能出现的异常做兜底，比如调用send同步方法发送失败时，则尝试将消息存储到db，然后由后台线程定时重试，确保消息一定到达Broker。&lt;/p>
&lt;h3 id="消费者幂等">消费者幂等&lt;/h3>
&lt;p>在消费之前判断唯一键是否在关系数据库中存在。如果不存在则插入，并消费，否则跳过。（实际过程要考虑原子性问题，判断是否存在可以尝试插入，如果报主键冲突，则插入失败，直接跳过）&lt;/p>
&lt;h3 id="提高消费并行度">&lt;strong>提高消费并行度&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>增加 Consumer（加机器）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>提高单个 Consumer 的消费并行线程，5.x PushConsumer SDK 可以通过PushConsumerBuilder.setConsumptionThreadCount() 设置线程数，SimpleConsumer可以由业务线程自由增加并发，底层线程安全；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>建议使用5.x SDK的SimpleConsumer，每次接口调用设置批次大小，一次性拉取消费多条消息，多线程消费&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="rocketmq-connect">&lt;strong>RocketMQ Connect&lt;/strong>&lt;/h3>
&lt;p>类似 kafka Connecter 的 sink 组件，各种外部数据之间的传输 &amp;amp; 转换，EG:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Mysql 数据同步 ES&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PR 同步 influxDB&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>目前性能最好最稳定组件最多的是 Kafka，rocketMq 不用考虑这个。&lt;/p>
&lt;h2 id="faq">FAQ：&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>如何重置消费点位&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://rocketmq.apache.org/zh/docs/featureBehavior/09consumerprogress" target="_blank" rel="noopener"
>消费进度管理 | RocketMQ (apache.org)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!--more-->- **订阅关系不一致的排查**
&lt;pre>&lt;code>- [订阅关系一致 | RocketMQ (apache.org)](https://rocketmq.apache.org/zh/docs/bestPractice/05subscribe)
&lt;/code>&lt;/pre>
&lt;!--more-->- 创建新的 ConsumerGroup 从哪里开始消费
&lt;pre>&lt;code>- 3.x/4.x SDK 则比较复杂，如果首次启动是在发送的消息在三天之内，那么消费者会从服务器中保存的第一条消息开始消费；如果发送的消息已经超过三天，则消费者会从服务器中的最新消息开始消费，也就是从队列的尾部开始消费。再次重新启动后，会从最后一次的消费位置继续消费。
&lt;/code>&lt;/pre>
&lt;!--more-->- **当消费失败的时候如何重新消费消息？**
&lt;pre>&lt;code>- 在集群模式下，消费的业务逻辑代码会返回消费失败状态，或者抛出异常，如果一条消息消费失败，则会按照设置的最大重试次数重试，之后该消息会被丢弃。
&lt;/code>&lt;/pre>
&lt;!--more--> - 在广播消费模式下，广播消费仍然保证消息至少被消费一次，但不提供重发的选项。
&lt;ul>
&lt;li>
&lt;p>&lt;strong>消息在服务器上可以保存多长时间？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>默认 3 天&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!--more-->- 常见错误码原因 &amp; 解决方案
&lt;pre>&lt;code>- [常见问题解答 | RocketMQ (apache.org)](https://rocketmq.apache.org/zh/docs/bestPractice/06FAQ#4-%E9%94%99%E8%AF%AF)
&lt;/code>&lt;/pre>
&lt;!--more-->
&lt;h2 id="控制台排查问题指南">控制台排查问题指南&lt;/h2>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_5ef9a8a9-cdc8-4234-bedb-f98903c3b932.png"
width="3150"
height="1942"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hubba4c47bb7056711b78ec9cafdf1fea0_516918_0f38d2397b13e25564f022e5cd26c0a1.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hubba4c47bb7056711b78ec9cafdf1fea0_516918_583ef47d6f73781f6256a46f729c872f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="389px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_16604ffa-a815-4c28-80d8-9e9dd75499a1.png"
width="1996"
height="1496"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hu44e6420345410bad085be99983a3d960_195580_e09410ebe44a1e100dc18994f47fc1d0.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hu44e6420345410bad085be99983a3d960_195580_c67c9b27462806e8c4436fb05fbaaea1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_78d585b9-a8f3-42d7-8c87-f523d39595e5.png"
width="1940"
height="1624"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hu35c98683dbfa1613a682489770616eee_328848_5945fe8abc651c5757bc37796a91610f.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hu35c98683dbfa1613a682489770616eee_328848_2b5e73d42b6717e7f10f008b7681762c.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="119"
data-flex-basis="286px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_df9ae5e8-cc89-4b24-b1ed-e00babbc6502.png"
width="1922"
height="1142"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hu6df363298a1dd4fff603b5cc8ab7a180_147082_59053ef62d7967de3853f7985c1a558b.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hu6df363298a1dd4fff603b5cc8ab7a180_147082_2a2258a98c624e32ed4ab66c63e56b11.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="403px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_0f7b9b3e-48fb-406a-8bf0-40b0e9b306c0.png"
width="3042"
height="1408"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hu5595422ed2cb71008148b914396322d0_370135_d5148c25456efd7ab719310791cbf12c.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hu5595422ed2cb71008148b914396322d0_370135_66fa1c16911086a9f76db9b6b3f783fb.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="518px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.env.wtf/p/overview-of-rocketmq/media/s3.us-west-2.amazonaws.com_d20b8049-f424-4cdd-a678-3ad6de43c15d.png"
width="1330"
height="292"
srcset="https://blog.env.wtf/p/overview-of-rocketmq/media/_hu8344df3cf320bb34635da43e1b1103db_42314_23c708df25bb90f63feebdad4938ac0f.png 480w, https://blog.env.wtf/p/overview-of-rocketmq/media/_hu8344df3cf320bb34635da43e1b1103db_42314_1e8a1365f3563b48cd717025d118a3ec.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="455"
data-flex-basis="1093px"
>&lt;/p></description></item><item><title>打造适合自己的背单词方法</title><link>https://blog.env.wtf/p/memorize-vocabulary-words/</link><pubDate>Mon, 17 Apr 2023 09:39:00 +0700</pubDate><guid>https://blog.env.wtf/p/memorize-vocabulary-words/</guid><description>&lt;img src="https://blog.env.wtf/p/memorize-vocabulary-words/media/s3.us-west-2.amazonaws.com_041717293180_01911681109917_.pic.jpg" alt="Featured image of post 打造适合自己的背单词方法" />&lt;p>每个人都应该有自己的提升词汇量的习惯，很可惜我在今年才醒悟英语的重要性，深刻认识自己之前错误的学习和记忆方法，本篇文章和大家分享下，我是如何找到适合自己的单词记忆方式。&lt;/p>
&lt;p>&lt;img src="https://blog.env.wtf/p/memorize-vocabulary-words/media/s3.us-west-2.amazonaws.com_62b12b3c-c051-4079-86a5-08f430c4c265.jpeg"
width="5760"
height="3147"
srcset="https://blog.env.wtf/p/memorize-vocabulary-words/media/_hu2aa06a2338f35378b5be64a48d06eb47_574954_c615272d29cccfa8f6a81b275b9fdea3.jpeg 480w, https://blog.env.wtf/p/memorize-vocabulary-words/media/_hu2aa06a2338f35378b5be64a48d06eb47_574954_823b0ca874a56440a90cf2f4b2bab54a.jpeg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="439px"
>&lt;/p>
&lt;h2 id="维护自己的生词本">维护自己的生词本&lt;/h2>
&lt;p>相信每个人，特别是 IT 从业者，都一定有查询生词的工具与手段，包括但不限于：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>网页插件查词（沙拉查词）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地词典（欧陆词典）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>快捷键取词查词（Bob）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>youtube &amp;amp; netflix 字幕翻译插件 (language reactor)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>闪卡（Anki）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>……&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>包括以上工具还有很多，这么多年我都使用过，但是英语一直无法提升，我总结了我忽视的最重要的一点原因：完全没有复习查过的重要的单词，每次遇到生词，看下解释，结束。下次再看到，瞬间看下解释，结束，只有出现 15+ 次超级频繁的单词会恰好适应记忆曲线所慢慢记忆，其余的单词早就抛在脑后了，所以复习生词本是重中之重的一个手段，但是每个软件的生词本太分散了，所以我今年开始只使用 &lt;strong>eudic&lt;/strong> (欧路词典)，它可以做到全平台云同步，然后每周导出我需要 &lt;strong>review&lt;/strong> 的生词在 「不背单词」上进行记忆 &amp;amp; 学习。&lt;/p>
&lt;p>我认为：记忆自己维护的生词本对比记忆： &lt;em>&lt;strong>coca 、雅思、六级&lt;/strong>&lt;/em> 要能坚持的下去，因为记忆单词初期最难的问题是：无法坚持！为什么我无法坚持学习呢？我分析有以下原因：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>有的单词太难记，感觉记了也没用，开始怀疑词书&lt;/p>
&lt;/li>
&lt;li>
&lt;p>枯燥，记了这么多能用几个？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不够重视，感觉今天不记也 OK？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>然后我从2月开始就维护了自己的生词本，到今天已经维护了 1000 + 生词，自己维护的生词都是在书中或者各种网站经常看到的，记忆起来比较主动，首先知道是有用的，也都是眼熟的，也有了记忆的动力，并且这些单词都是实打实的生词。&lt;/p>
&lt;h2 id="如何获取生词">如何获取生词&lt;/h2>
&lt;p>我的生词获取方式是一下三点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>hack news | twitter | reddit | github 等日常网站&lt;/p>
&lt;/li>
&lt;li>
&lt;p>英文原本小说&lt;/p>
&lt;/li>
&lt;li>
&lt;p>英语字母看英文动画片（开心汉堡店、怪诞小镇、马男波杰克…）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我会将看到至少 2 次的单词，或者总是眼熟但那是不明其意的单词加入到我的生词本中。当然期间也同时在进行着复习，如果幸运的你看到了之前记忆过得单词，大脑会分泌多巴胺，&lt;span style="background-color: rgba(251, 243, 219, 1);">那种瞬间惊喜就是最好的回报。&lt;/span>&lt;/p>
&lt;h2 id="自己的生词本的弊端">自己的生词本的弊端&lt;/h2>
&lt;p>但是记忆了 50 天后复盘发现了一些问题：我每天维护生词的速度远远赶不上记忆的速度了，以我目前的速度，每天可以无痛背50 左右个单词，但是每天只有 20 个生词可背，导致每天复习完就没事做。&lt;/p>
&lt;p>还有一点：英文小说中有大量的形容词，假如我加入了这些单词到我的生词本，其实记忆的效果不如直接记忆他的”原型“，我举几个例子：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>incorporating (incorporate)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>flattering (flatter)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>supposedly (supposed)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>其实如果正确的掌握了原型，很多 形容词 名词 之前的变形就不用记了，所以逐渐的我已经明白词书的重要性了，也明白词书的「存在即合理」的道理，于是已经切换到 「雅思词库」进行记忆了，但是生词本的维护还是没有放弃，并且还是会定期 review，通过这 50 天的磨炼我也不算是走了弯路，反而我觉得我获得了最重要的东西：坚持 &amp;amp; 习惯 ！通过连续不断地 50 天打卡，我已经养成了背单词的习惯。&lt;/p>
&lt;h2 id="记单词在记什么">记单词在记什么&lt;/h2>
&lt;p>后来经过复盘，前 1000 个生词我花的时间有点太多了，用了 5000 分钟，因为我一直在寻找防范，我总结的经验是这样的：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>1：先看词性，找到原型，如有有原型，先记忆原型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2：看词根词缀，如果合乎我们记忆的逻辑，可以优先使用词根词缀记忆取代死记硬背，当然有的词根词缀很离谱，就可以无视了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>3：固定搭配和短语，这个太重要了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>4：实在难记，使用大量例句磨一磨耳朵，没别的办法了，确实有很多词根很难记&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="如何复习">如何复习&lt;/h2>
&lt;p>想必很多记忆曲线的软件都是默认以天为单位：今天学习的，明天复习。明天答对的 N 天后复习，答错的还是第二天复习，看起来没什么问题，但是现实是：这是软件的骗局，正常应该是以小时为单位，甚至是当天复习两遍，但是如果软件默认就这样交互，没人愿意用了，因为太折磨了，所以第二天我们会忘记巨量的单词，这个时候我的方法是：当天复习两遍，不需要复习很久。&lt;/p>
&lt;p>比如每天复习 200 单词，第一次软件默认的逻辑我们可能需要复习 30 分钟左右，但是过 几个小时我们按列表顺一遍就可以了，大概只需要 10分钟，过几个小时再顺一遍，可能只需要 8 分钟，但是这对第二天以及长期记忆是相当有好处的（亲身体会）&lt;/p>
&lt;h2 id="什么时候张嘴">什么时候张嘴&lt;/h2>
&lt;p>我看过很多大佬的复盘，总结的经验是：如果你没有语言环境（人在国外、身边母语者）那就轻易不要张嘴，知道自己的词汇量达到 7000 - 8000 并且大量 input 美剧，英语之后，可以张嘴了。在没有达到条件的时候轻易先不张嘴进行 output，否则很容易中式英语那个味道就来了，而且后期不好改正，先进行输入，没有输入就没有输出。&lt;/p>
&lt;h2 id="不记单词只看书法">不记单词只看书法&lt;/h2>
&lt;p>有很多大佬推荐：不需要记忆单词，只要看书就好了，找到适合自己输入的 N+1 可理解输入的书，然后进行大量阅读就好了。&lt;/p>
&lt;p>我开始非常赞同这个方式，我也在1月进行了亲身实践，我的结论是：不适合我自己&lt;/p>
&lt;ul>
&lt;li>
&lt;p>找书困难（适合自己蓝思值太简单的书都很幼稚的）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>看书标记的单词不复习（看了又忘，有的单词读完一本也没记住，只是特别眼熟）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有成就感（读完一本书我究竟掌握了多少单词）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这一些导致我无法坚持，我不批判这种学习方式，我只想说，这种方式比较适合从小培养，从小阅读，如果你像我一样：已经大学毕业英语水平还是一般，这种方法就不适合初期的我们，我们现在就是要提升单词量，提升到一个能说得过去的程度再说，比如 8000 - 10000。&lt;/p>
&lt;p>然后再进行阅读，这样的阅读、能起到复习的作用，还能学习固定搭配，提升词汇量，书籍的选择性也相当多，比如我目前可以阅读 850L 左右蓝思值的书，没有太大的压力，每页查询单词 2 个左右，相反，如果不提升词汇量，初期很难熬过去，会对阅读进行抵触。&lt;/p>
&lt;p>一下是一些学习记录，我的规划是：2023 词汇至少突破 10000，然后进行泛读 &amp;amp; 输出。&lt;/p></description></item></channel></rss>